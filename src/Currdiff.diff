Index: EvaluatorCommands.c
===================================================================
--- EvaluatorCommands.c	(revision 212)
+++ EvaluatorCommands.c	(working copy)
@@ -205,7 +205,7 @@
         /*
          * Add the formatted line to the output.
          */
-        rc = StrAddLine(&pszTmp,cbBuf, szLine, &cWritten);
+        rc = StrAddLine(&pszTmp, cbBuf, szLine, &cWritten);
         if (RC_FAILURE(rc))
             break;
     }
@@ -270,6 +270,20 @@
                 }
             }
         }
+
+
+        /*
+         * Add the extra description if any.
+         */
+        int cAddDesc = StrLen(pReg->szAddDesc) + 2;
+        if (   cAddDesc > 0
+            && cWritten + cAddDesc < cbBuf)
+        {
+            StrCat(pszBuf, "\n" /* 2 */);
+            StrNCat(pszBuf, pReg->szAddDesc, sizeof(pReg->szAddDesc));
+        }
+        else
+            DEBUGPRINTF(("Insufficient space for formatting register. szName=%s\n", pReg->szName));
     }
     else
         DEBUGPRINTF(("Insufficient space for formatting register. szName=%s\n", pReg->szName));
@@ -538,6 +552,94 @@
 }
 
 
+int FnCSAttr(PEVALUATOR pEval, PATOM pAtom, char **ppszResult)
+{
+    AssertReturn(ppszResult, RERR_INVALID_PARAMETER);
+    *ppszResult = NULL;
+
+    static REGBITDESC aBitDesc[32] =
+    {
+    /* Bit */   /* Type */     /* Name */       /* Long Name */            /* Description */
+    /*  0  */   { enmNormal,   "Seg. type",    "Segment type",             "Segment type" },
+    /*  1  */   { enmInRange,  "",             "",                         "" },
+    /*  2  */   { enmInRange,  "",             "",                         "" },
+    /*  3  */   { enmInRange,  "",             "",                         "" },
+    /*  4  */   { enmNormal,   "Desc. type",   "Descriptor type",          "Descriptor type (0=system,1=code/data)" },
+    /*  5  */   { enmNormal,   "DPL",          "DPL",                      "Descriptor privilege level" },
+    /*  6  */   { enmInRange,  "",             "",                         "" },
+    /*  7  */   { enmNormal,   "Present",      "Present",                  "If set, segment is present" },
+    /*  8  */   { enmNormal,   "Limit",        "Segment limit (hi)",       "Segment limit (high bits 16:19)" },
+    /*  7  */   { enmInRange,  "",             "",                         "" },
+    /* 10 */    { enmInRange,  "",             "",                         "" },
+    /* 11 */    { enmInRange,  "",             "",                         "" },
+    /* 12 */    { enmNormal,   "Available",    "Available",                "If set, available for use by system software" },
+    /* 13 */    { enmNormal,   "Long",         "Long",                     "64-bit code segment (long mode only)" },
+    /* 14 */    { enmNormal,   "DefBig",       "Default/Big",              "Default operation size (0=16-bit, 1=32-bit)" },
+    /* 15 */    { enmNormal,   "Gran",         "Granularity",              "Granularity (0=byte scaling,1=4KB scaling)" },
+    /* 16 */    { enmNormal,   "Unusable",      "Unusable",                "Unusable segment (Intel VT-x only)" },
+    /* 17 */    { enmRsvd,      "",             "",                        "" },
+    /* 18 */    { enmRsvd,      "",             "",                        "" },
+    /* 19 */    { enmRsvd,      "",             "",                        "" },
+    /* 20 */    { enmRsvd,      "",             "",                        "" },
+    /* 21 */    { enmRsvd,      "",             "",                        "" },
+    /* 22 */    { enmRsvd,      "",             "",                        "" },
+    /* 23 */    { enmRsvd,      "",             "",                        "" },
+    /* 24 */    { enmRsvd,      "",             "",                        "" },
+    /* 25 */    { enmRsvd,      "",             "",                        "" },
+    /* 26 */    { enmRsvd,      "",             "",                        "" },
+    /* 27 */    { enmRsvd,      "",             "",                        "" },
+    /* 28 */    { enmRsvd,      "",             "",                        "" },
+    /* 29 */    { enmRsvd,      "",             "",                        "" },
+    /* 30 */    { enmRsvd,      "",             "",                        "" },
+    /* 31 */    { enmRsvd,      "",             "",                        "" },
+    };
+
+    REGDESC32 CSAttrDesc;
+    memset(&CSAttrDesc, 0, sizeof(CSAttrDesc));
+    StrCopy(CSAttrDesc.szName, sizeof(CSAttrDesc.szName), "CSAttr");
+    StrCopy(CSAttrDesc.szDesc, sizeof(CSAttrDesc.szDesc), "Code Segment Attributes (Intel x86)");
+    StrCopy(CSAttrDesc.szAddDesc, sizeof(CSAttrDesc.szAddDesc),
+            "---------------------------\n"
+            "Code and Data Segment Types\n"
+            "---------------------------\n"
+            "Decimal  Binary   Type    Description\n"
+            "0        0 0 0 0  Data    Read-Only\n"
+            "1        0 0 0 1  Data    Read-Only,  accessed\n"
+            "2        0 0 1 0  Data    Read/Write\n"
+            "3        0 0 1 1  Data    Read/Write, accessed\n"
+            "4        0 1 0 0  Data    Read-Only,  expand-down\n"
+            "5        0 1 0 1  Data    Read-Only,  expand-down, accessed\n"
+            "6        0 1 1 0  Data    Read/Write, expand-down\n"
+            "7        0 1 1 1  Data    Read/Write, expand-down, accessed\n"
+            "8        1 0 0 0  Code    Execute-Only\n"
+            "9        1 0 0 1  Code    Execute-Only, accessed\n"
+            "10       1 0 1 0  Code    Execute/Read\n"
+            "11       1 0 1 1  Code    Execute/Read, accessed\n"
+            "12       1 1 0 0  Code    Execute-Only, conforming\n"
+            "13       1 1 0 1  Code    Execute-Only, conforming, accessed\n"
+            "14       1 1 1 0  Code    Execute/Read, conforming\n"
+            "15       1 1 1 1  Code    Execute/Read, conforming, accessed\n");
+    CSAttrDesc.paRegBitDesc = aBitDesc;
+
+    if (pAtom)
+    {
+        FLOAT dValue = pAtom->u.dValue;
+
+        FLOAT dAbsResult = FABSFLOAT(dValue);
+        if (!CanCastTo(dAbsResult, MAX_U64INTEGER))
+            return RERR_INVALID_COMMAND_PARAMETER;
+
+        U64INTEGER uValue = (U64INTEGER)dAbsResult;
+        *ppszResult = StrFormatReg32(uValue, &CSAttrDesc);
+    }
+    else
+        *ppszResult = StrFormatRegDesc32(&CSAttrDesc);
+
+
+    return RINF_SUCCESS;
+}
+
+
 /**
  * g_aCommands: Table of commands.
  */
@@ -547,7 +649,8 @@
     { "cr0",                            FnCr0,               "<x86reg>",      "Intel x86: CR0 register format." },
     { "cr4",                            FnCr4,               "<x86reg>",      "Intel x86: CR4 register format." },
     { "eflags",                         FnEflags,            "<[e|r]flags>",  "Intel x86: EFLAGS register format." },
-    { "efer",                           FnEfer,              "<x86reg>",      "Intel x86: EFER format." }
+    { "efer",                           FnEfer,              "<x86reg>",      "Intel x86: EFER format." },
+    { "csattr",                         FnCSAttr,            "<csattr>",      "Intel x86: CS segment attributes." }
 };
 
 /** Total number of commands in the table. */
Index: EvaluatorCommands.h
===================================================================
--- EvaluatorCommands.h	(revision 212)
+++ EvaluatorCommands.h	(working copy)
@@ -24,6 +24,7 @@
 #define EVALUATOR_COMMANDS_H___
 
 #include "EvaluatorInternal.h"
+#include "Assert.h"
 
 /**
  * Register type bit.
@@ -36,6 +37,8 @@
     enmRsvdMB1,
     /** Reserved Must Be 0. */
     enmRsvdMBZ,
+    /** Part of a bit range, previously recognized (normal) bit. */
+    enmInRange,
     /** Normal bit. */
     enmNormal
 } REGBITTYPE;
@@ -49,7 +52,7 @@
     /** Register bit type.  */
     REGBITTYPE      enmType;
     /** Name of this bit. */
-    char            szName[32];
+    char            szName[64];
     /** Description name. */
     char            szLongName[128];
     /** Long description of this bit. */
@@ -70,6 +73,8 @@
     char        szName[64];
     /** Long description of the register. */
     char        szDesc[256];
+    /** Additional description (notes, tables etc.) */
+    char        szAddDesc[2048];
     /** Pointer to bit descriptor array for 32 bits. */
     PREGBITDESC paRegBitDesc;
 } REGDESC32;
Index: StringOps.h
===================================================================
--- StringOps.h	(revision 212)
+++ StringOps.h	(working copy)
@@ -55,7 +55,7 @@
 
 void *MemAllocZ(size_t cb);
 char *StrDup(const char *pszSrc);
-int StrCopy(char *pszDst, size_t cbDst, const char *pszSrc);
+int   StrCopy(char *pszDst, size_t cbDst, const char *pszSrc);
 char *StrStrip(char *pszBuf);
 char *StrStripLF(char *pszBuf, bool *pfStripped);
 char *StrValue32AsBinary(U64INTEGER uValue, bool fNegative, bool fDoubleSpace, bool fFullLength, size_t *pcDigits);
